{
  "hash": "1a6292e5baec47a8b43e6af171ce4635",
  "result": {
    "markdown": "---\ntitle: \"Cost-Volume-Profit(CVP)\"\nbibliography: pricing.bib\nfilters:\n   - lightbox\nlightbox: auto\neditor_options: \n  chunk_output_type: console\nknitr:\n  opts_chunk: \n    echo: true\n    waring: false\n    collapse: true\n    comment: \"#>\"  \n---\n\n\n\n# 개요\n\n원가-조업도-이익(Cost-Volume-Profit, CVP) 분석에서 **이익(Profit)**이 조업도(Volume), 원가(Cost)의 변화에 어떻게 변화하는지 분석하는 경영학 기법으로 이를 통해서 목표 이익, 목표판매량, 목표매출액 등을 산출해볼 수 있다. 특히, 손익분기점에 도달하려면 몇개의 상품을 팔아야하는지 분석할 수도 있다.\n\n원가는 고정비와 변동비로 구분하고 이익은 매출에서 비용을 제하면 구할 수고 조업도(Volume)는 기업의 활동정도로 제품 생산량, 노동시간, 기계작업시간 등으로 측정된다.\n\n- 구성요소\n    - 가격\n    - 판매량\n    - 단가(Unit Variable Cost)\n    - 총고정비(Total Fixed Cost)\n    - Product(Sales) Mix\n\n* 목표이익 = (가격 - 비용) X 목표판매량 - 총고정비용\n\n# 손익분기점 방법\n\n손익분기접(Break-Even)은 이익도 손해도 없는 상황으로 다양한 방식으로 계산을 할 수 있다.\n\n[출처: [@cafferky2010breakeven] ]{.aside}\n\n## 총비용 방법\n\n- 손익분기점: 총비용 = 총매출\n  - 총비용 = 고정비용 + 변동비용\n  - 총매출 = 판매량 X 단가\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n#> ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n#> ✔ ggplot2 3.3.6      ✔ purrr   0.3.4 \n#> ✔ tibble  3.1.8      ✔ dplyr   1.0.10\n#> ✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n#> ✔ readr   2.1.2      ✔ forcats 0.5.2\n#> Warning: 패키지 'tibble'는 R 버전 4.2.1에서 작성되었습니다\n#> Warning: 패키지 'tidyr'는 R 버전 4.2.1에서 작성되었습니다\n#> Warning: 패키지 'dplyr'는 R 버전 4.2.1에서 작성되었습니다\n#> Warning: 패키지 'stringr'는 R 버전 4.2.1에서 작성되었습니다\n#> Warning: 패키지 'forcats'는 R 버전 4.2.1에서 작성되었습니다\n#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\nlibrary(testthat)\n#> \n#> 다음의 패키지를 부착합니다: 'testthat'\n#> The following object is masked from 'package:dplyr':\n#> \n#>     matches\n#> The following object is masked from 'package:purrr':\n#> \n#>     is_null\n#> The following objects are masked from 'package:readr':\n#> \n#>     edition_get, local_edition\n#> The following object is masked from 'package:tidyr':\n#> \n#>     matches\n\nfixed_costs    = 520000\nvariable_costs = 1105000\ntotal_costs    = 1625000\n\ntest_that(\"총원가 = 고정비 + 변동비\", {\n  expect_equal(fixed_costs + variable_costs, total_costs)\n})\n#> Test passed 🥳\n\ntotal_costs <- fixed_costs + variable_costs\ntotal_revenue = 1625000\n\ntest_that(\"총매출 - 총원가 = 0\", {\n  expect_equal(total_revenue - total_costs, 0)\n})\n#> Test passed 🥳\n```\n:::\n\n  \n  \n## 공헌이익 방법\n\n공헌이익(Contribution Margin)은 제품가에서 변동비를 뺀 값으로 다음과 같이 표현한다.\n\n$$\\text{(단위) 공헌이익 =  단위 가격 - 단위 변동비}$$\n\n- 고정비: 520,000\n- 단위 가격: 25\n- 단위 변동비: 17\n- (단위) 공헌이익: (25-17) = 8\n\n\n문제는 판매량이 얼마가 되어야 최소 손실을 보지 않게 될까?\n수식으로 표현하면 다음과 같이 구할 수 있다.\n\n$520,000 - (25-17) * volume = 0$\n\n방정식을 풀면 다음과 같이 구할 수 있다.\n\n$volume = \\frac{520,000}{8} = 65,000$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsales_fn <- function(volume) (25-17) * volume - 520000\n\nbe_volume <- uniroot(sales_fn, lower = 0, upper = 100000)$root\nbe_volume\n#> [1] 65000\n```\n:::\n\n\n시각적으로 나타내면 다음과 같다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(volume = seq(0, 100000, 100)) %>% \n  mutate(profit = map_dbl(volume, sales_fn)) %>% \n  ggplot(aes(x = volume, y = profit)) +\n    geom_line() +\n    scale_x_continuous(labels = scales::comma) +\n    scale_y_continuous(labels = scales::comma) +\n    theme_bw(base_family = \"NanumGothic\") +\n  labs(title = \"손익분기점 판매량 - 공헌이익 방법\",\n       x = \"판매량\",\n       y = \"이익\") +\n    geom_hline(yintercept = 0, color = \"gray50\") +\n    geom_point(aes(x= be_volume, y = 0), size = 3, color = \"blue\") +\n    annotate(\"text\", x = 80000, y = -50000, \n             label = glue::glue(\"손익분기점: {scales::comma(be_volume)}\"), \n             size = 5, color = \"blue\")  \n#> Warning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): 윈도우즈 폰트데\n#> 이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): 윈도우즈 폰트데\n#> 이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): 윈도우즈 폰트데\n#> 이터베이스에서 찾을 수 없는 폰트페밀리입니다\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n#> Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, : 윈\n#> 도우즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n```\n\n::: {.cell-output-display}\n![](cvp_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n## 목표 이익 방법\n\n\n손익분기점에 맞추는 것이 목표가 아니고 사업에서는 이익을 남기는 것이 목표라서 다음과 같이 목표 이익을 더하여 목표이익을 달성하는데 필요한 판매수량을 계산한다.\n\n예를 들어 고정비(즉, 투자)의 10%를 목표로 삼아 목표달성을 위해 필요한 판매량을 계산해보자.\n\n\n$$\\text{목표이익 달성을 위한 판매수량} = \\frac{고정비용+목표이익}{(단위) 공헌이익}$$\n\n- 고정비: 520,000\n- 단위 가격: 25\n- 단위 변동비: 17\n- (단위) 공헌이익: (25-17) = 8\n- 목표이익: 52,000\n\n수식으로 정리하여 방정식을 풀면 판매량을 다음과 같이 계산할 수 있다.\n\n\n$$\\frac{520,000 + 52,000}{8} = 71,500$$\n\n이것을 확대하면 다른 사항도 고려하여 목표를 달성하는데 필요한 판매목표수량을 계산할 수 있다.\n\n\n- 고정비: 520,000\n- 단위 가격: 25\n- 단위 변동비: 17\n- (단위) 공헌이익: (25-17) = 8\n- 이익관련 전체 목표\n    - 목표이익: 52,000\n    - 우선주 배당: 13,000\n    - 일반주 배당: 20,000\n\n$$\\frac{520,000 + 52,000 + 13,000 + 20,000}{8} = 75,625$$\n    \n프로그래밍을 통해 다음과 같이 계산할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_costs = 520000\ndesired_profit = 52000\ndividends_prefer = 13000\ndividends_common = 20000\n\ncontribution_margin = (25-17)\n\ncm_be_volume <- (fixed_costs + desired_profit + dividends_prefer + dividends_common) / contribution_margin\n\ntest_that(\"목표이익 검정\", {\n  expect_equal(cm_be_volume, 75625)\n})\n#> Test passed 🥳\n```\n:::\n\n\n시각화를 통해서 상기 사항을 다음과 같이 확인할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 고정비, 목표이익, 배당 함수 --------\nfixed_cost_fn <- function(volume) (25-17) * volume - 520000\ndesired_profit_fn <- function(volume) (25-17) * volume - 520000 - 52000\ndividend_fn <- function(volume) (25-17) * volume - 520000 - 52000 - 13000 - 20000\n\n# 시각화를 위한 데이터프레임\ngoals_tbl <- tibble(volume = seq(0, 100000, 100)) %>% \n  mutate(fixed_cost    = map_dbl(volume, fixed_cost_fn),\n         desired_profit = map_dbl(volume, desired_profit_fn),\n         dividend       = map_dbl(volume, dividend_fn)) %>% \n  pivot_longer(fixed_cost:dividend) %>% \n  mutate(name = factor(name, levels = c(\"fixed_cost\",\n                                        \"desired_profit\",\n                                        \"dividend\"),\n                       labels = c(\"고정비\", \"목표이익\", \"배당\")))\n\n\nfixed_cost_bep <- uniroot(fixed_cost_fn, lower = 0, upper = 100000)$root\ndesired_profit_bep <- uniroot(desired_profit_fn, lower = 0, upper = 100000)$root\ndividend_bep <- uniroot(dividend_fn, lower = 0, upper = 100000)$root\n\n# 시각화\ngoals_tbl %>% \n  ggplot(aes(x = volume, y = value, color = name)) +\n    geom_line() +\n    scale_x_continuous(labels = scales::comma) +\n    scale_y_continuous(labels = scales::comma) +\n    theme_bw(base_family = \"NanumGothic\") +\n  labs(title = \"손익분기점 판매량 - 목표이익달성\",\n       x = \"판매량\",\n       y = \"이익\",\n       color = \"구분\") +\n    geom_hline(yintercept = 0, color = \"gray50\") +\n    geom_point(aes(x= fixed_cost_bep, y = 0), size = 3, color = \"blue\") +\n    geom_point(aes(x= desired_profit_bep, y = 0), size = 3, color = \"green\") +\n    geom_point(aes(x= dividend_bep, y = 0), size = 3, color = \"red\") +\n    annotate(\"text\", x = 55000, y = 50000, \n             label = glue::glue(\"{scales::comma(fixed_cost_bep)}\"), \n             size = 4.5, color = \"blue\") +\n    annotate(\"text\", x = 85000, y = 30000, \n             label = glue::glue(\"{scales::comma(desired_profit_bep)}\"), \n             size = 4.5, color = \"green\") +\n    annotate(\"text\", x = 85000, y = -50000, \n             label = glue::glue(\"{scales::comma(dividend_bep)}\"), \n             size = 4.5, color = \"red\") +\n  scale_color_manual(values = c(\"blue\", \"green\", \"red\")) \n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n#> Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, : 윈\n#> 도우즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n\n#> Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : 윈도우\n#> 즈 폰트데이터베이스에서 찾을 수 없는 폰트페밀리입니다\n```\n\n::: {.cell-output-display}\n![](cvp_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n    \n# 고정비와 변동비 구분\n\n고정비와 변동비를 구분할 수 있으면 순익분기점을 추정하는데 큰 도움이 된다. \n대표적인 방법으로 선형회귀식을 통해 고정비와 변동비를 추정할 수 있다.\n\n선형회귀식을 계산하는데 필요한 것이 데이터다. 만약, 판매량과 총비용에 대한 데이터가 관측점별로 준비되어 있다면 이를 활용하여 상대적으로 데이터에 기반하여 고정비와 변동비를 정확히 도출할 수 있다. 즉, 연도별 총비용 데이터와 판매량 데이터를 통해 고정비와 변동비를 선형회귀모형을 통해 추정할 수 있다.\n\n$$Y_{총비용} = \\alpha_{고정비용} + \\beta_{변동비} \\times 판매량$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(broom)\n#> Warning: 패키지 'broom'는 R 버전 4.2.1에서 작성되었습니다\n\ncost_tbl <- tribble(~\"연도\", ~ \"판매량\", ~\"총비용\",\n                    2010, 160, 2700,\n                    2011, 170, 2795,\n                    2012, 150, 2610,\n                    2013, 140, 2500,\n                    2014, 180, 2800)\n\ncost_lm <- lm(총비용 ~ 판매량, data = cost_tbl)\n  \ncoef_tbl <- broom::tidy(cost_lm)\n\nfixed_cost_intercept <- coef_tbl %>% filter(term == \"(Intercept)\") %>% pull(estimate)\n\nvariable_cost_slope <- coef_tbl %>% filter(term == \"판매량\") %>% pull(estimate)\n```\n:::\n\n\n\n상기 데이터를 통해 해당 기업 변동비와 고정비를 추정하면 다음과 같다.\n\n$$Y_{총비용} = 1,425 + 7.85 \\times 판매량$$\n\n- 고정비용: 1,425\n- 변동비용: 7.85\n\n\n\n\n\n\n",
    "supporting": [
      "cvp_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}